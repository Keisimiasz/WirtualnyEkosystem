Lab1:
1. Co to jest zintegrowane Å›rodowisko programistyczne (IDE)?
IDE to aplikacja uÅ‚atwiajÄ…ca programowanie, Å‚Ä…czÄ…ca edytor kodu, kompilator, debugger i inne narzÄ™dzia. PrzykÅ‚ady: Visual Studio Code, PyCharm, IntelliJ IDEA.

2. Jaki jest zwiÄ…zek miÄ™dzy C a C++?
C++ to rozszerzenie C, dodajÄ…ce programowanie obiektowe i inne funkcje. C jest proceduralny i uÅ¼ywany w systemach niskopoziomowych, a C++ wspiera obiektowoÅ›Ä‡ i jest stosowany np. w grach i aplikacjach.

3. Jak wyglÄ…da struktura najprostszego programu w C++?
Program skÅ‚ada siÄ™ z:

#include <iostream> â€“ do obsÅ‚ugi wejÅ›cia/wyjÅ›cia,
int main() {} â€“ gÅ‚Ã³wnej funkcji programu,
std::cout << "Hello, World!"; â€“ wyÅ›wietlenia tekstu,
return 0; â€“ zakoÅ„czenia programu.


Lab2:


1.RÃ³Å¼nica miÄ™dzy statycznym a dynamicznym typowaniem:

Statyczne typowanie oznacza, Å¼e typ zmiennej jest okreÅ›lany w czasie kompilacji (np. w C, C++).
Dynamiczne typowanie oznacza, Å¼e typ zmiennej jest przypisywany w czasie wykonania programu (np. w Pythonie, JavaScript).

2.Hermetyzacja: Hermetyzacja (enkapsulacja) to zasada programowania obiektowego, ktÃ³ra polega na ukrywaniu szczegÃ³Å‚Ã³w implementacyjnych klasy przed uÅ¼ytkownikami tej klasy i udostÄ™pnianiu tylko wybranych metod, ktÃ³re umoÅ¼liwiajÄ… interakcjÄ™ z obiektem.

3.WartoÅ›Ä‡ zmiennej k w podanych miejscach:

Listing 2.2:
Po linii 10: k = 3, w pÄ™tli while(k < 10) zmienna k zostanie zwiÄ™kszona zgodnie z warunkami (do momentu, kiedy k osiÄ…gnie 7).
Po linii 19: W wyniku dziaÅ‚ania instrukcji switch, wartoÅ›Ä‡ k bÄ™dzie wynosiÅ‚a 0 (ze wzglÄ™du na default).
Po linii 22: Zmienna k zostanie zmniejszona do 4 (po wykonaniu pÄ™tli for).

4.Niepoprawne deklaracje zmiennych w listing 2.3:

Linia 1: unsigned int = -3; â€“ brak nazwy zmiennej.
Linia 7: long = 3.2; â€“ brak nazwy zmiennej i przypisanie liczby zmiennoprzecinkowej do typu long.
Linia 8: unsigned double y = 3.5; â€“ typ unsigned nie jest stosowany do zmiennych typu double.

Odp do listingow:

Jakie rozszerzenie ma plik nagÅ‚Ã³wkowy i po co on jest?

Plik nagÅ‚Ã³wkowy w C++ ma rozszerzenie .h. SÅ‚uÅ¼y do deklarowania klas, funkcji, zmiennych i staÅ‚ych, ktÃ³re mogÄ… byÄ‡ uÅ¼ywane w innych plikach ÅºrÃ³dÅ‚owych. DziÄ™ki temu kod jest bardziej modularny i Å‚atwiejszy do zarzÄ…dzania .
Jakie rozszerzenie ma plik ÅºrÃ³dÅ‚owy i po co on jest?

Plik ÅºrÃ³dÅ‚owy w C++ ma rozszerzenie .cpp. Zawiera definicje funkcji i metod zadeklarowanych w plikach nagÅ‚Ã³wkowych. Kompilator przetwarza pliki ÅºrÃ³dÅ‚owe, aby stworzyÄ‡ plik wykonywalny .
Listing 2.6, wiersze 1-3 â†’ Jaki jest efekt dyrektywy include?

Dyrektywa #include wÅ‚Ä…cza zawartoÅ›Ä‡ wskazanego pliku do kodu ÅºrÃ³dÅ‚owego przed jego kompilacjÄ…. W listingu 2.6 #include "zlab02.h", #include <iostream>, #include <limits> umoÅ¼liwia korzystanie z deklaracji z pliku nagÅ‚Ã³wkowego oraz funkcji wejÅ›cia/wyjÅ›cia i funkcji okreÅ›lajÄ…cych zakresy typÃ³w liczbowych .
Co oznacza operator :: (np. w linii 4 na listingu 2.5)?

Operator :: (operator zakresu) pozwala na okreÅ›lenie, do ktÃ³rej klasy lub przestrzeni nazw naleÅ¼y dana funkcja lub zmienna. W listingu 2.5 void ZLab02::zadanie_2_3() oznacza, Å¼e funkcja zadanie_2_3() naleÅ¼y do klasy ZLab02 .
Listing 2.7, wiersz 15 i 19 â†’ Dlaczego zastosowany zostaÅ‚ typ long?

Typ long zostaÅ‚ zastosowany, aby uniknÄ…Ä‡ przepeÅ‚nienia wartoÅ›ci liczbowych podczas obliczeÅ„ zakresÃ³w dla typÃ³w int i unsigned int .
Jaki jest efekt sÅ‚owa endl?

endl powoduje przejÅ›cie do nowej linii i wymusza oprÃ³Å¼nienie bufora strumienia wyjÅ›ciowego cout .
Dlaczego wyniki dzielenia sÄ… rÃ³Å¼ne?

RÃ³Å¼nice wynikajÄ… z typÃ³w zmiennych. JeÅ›li a i b sÄ… typu int, to a / b wykonuje dzielenie caÅ‚kowite, ignorujÄ…c czÄ™Å›Ä‡ uÅ‚amkowÄ…. Natomiast rzutowanie na double przed dzieleniem pozwala uzyskaÄ‡ precyzyjny wynik zmiennoprzecinkowy .
Listing 2.9, wiersz 5 â†’ Co tu siÄ™ dzieje?

W tym wierszu double e = static_cast<double>(a)/static_cast<double>(b); rzutuje a i b na double, dziÄ™ki czemu wynik dzielenia bÄ™dzie precyzyjniejszy i uwzglÄ™dni czÄ™Å›Ä‡ uÅ‚amkowÄ… .
Listing 2.12, wiersz 2 â†’ Czy zmienna wybor moÅ¼e mieÄ‡ typ double?

Nie, poniewaÅ¼ zmienna wybor jest uÅ¼ywana w instrukcji switch, a switch dziaÅ‚a tylko na typach caÅ‚kowitych (int, char, enum) .
Listing 2.12, wiersz 2 â†’ Czy zmienna wybor moÅ¼e mieÄ‡ typ int?

Tak, zmienna wybor moÅ¼e byÄ‡ typu int, poniewaÅ¼ jest uÅ¼ywana w instrukcji switch, ktÃ³ra obsÅ‚uguje wartoÅ›ci caÅ‚kowite .
Listing 2.12, wiersz 11 â†’ Co oznacza ||?

Operator || oznacza logiczne lub. WyraÅ¼enie wybor < 3 || wybor > 5 zwrÃ³ci true, jeÅ›li wybor bÄ™dzie mniejsze niÅ¼ 3 lub wiÄ™ksze niÅ¼ 5 .
Listing 2.12, wiersze 14-16 â†’ Jaka jest rola sÅ‚owa break?

break przerywa wykonanie switch, zapobiegajÄ…c wykonaniu kolejnych przypadkÃ³w w instrukcji wyboru .
Listing 2.14, wiersz 5 â†’ W jakim celu wskaÅºnikowi nadaje siÄ™ wartoÅ›Ä‡ nullptr?

nullptr oznacza, Å¼e wskaÅºnik nie wskazuje na Å¼adnÄ… istotnÄ… wartoÅ›Ä‡. Jest to dobry sposÃ³b na unikniÄ™cie uÅ¼ycia niezainicjalizowanego wskaÅºnika .
Listing 2.14, wiersz 11 â†’ Jak dziaÅ‚a operator &?

Operator & pobiera adres zmiennej i zwraca wskaÅºnik na tÄ™ zmiennÄ… .
Listing 2.14, wiersz 13 â†’ Po co jest znak *?

* oznacza dereferencjÄ™ wskaÅºnika, czyli pozwala na dostÄ™p do wartoÅ›ci, na ktÃ³rÄ… wskazuje wskaÅºnik .
Listing 2.17, wiersz 3 â†’ Jaki bÄ™dzie efekt wywoÅ‚ania instrukcji?

int tab[N]; deklaruje tablicÄ™ tab o N elementach, ktÃ³re bÄ™dÄ… przechowywaÄ‡ losowe liczby .
Listing 2.17, wiersz 6 â†’ Co tu siÄ™ dzieje?

uniform_int_distribution<short> dystr(min,max); tworzy generator liczb losowych w zadanym przedziale min do max .
Listing 2.16, wiersz 11 â†’ Jakie instrukcje znajdujÄ… siÄ™ w bloku pÄ™tli while?

WewnÄ™trzna pÄ™tla while losuje liczbÄ™ i sprawdza, czy jest wiÄ™ksza od poprzedniej, w przeciwnym razie ponawia losowanie .
Listing 2.16, wiersz 11 â†’ Jak w ogÃ³le dziaÅ‚a pÄ™tla while?

while wykonuje kod w swojej pÄ™tli dopÃ³ki warunek jest speÅ‚niony. W tym przypadku generuje liczby do momentu uzyskania ciÄ…gu niemalejÄ…cego .
Czy moÅ¼e zdarzyÄ‡ siÄ™, Å¼e warunek zakoÅ„czenia pÄ™tli while nie wystÄ…pi?

Tak, jeÅ›li generator liczb losowych nie wygeneruje odpowiedniej wartoÅ›ci, pÄ™tla while moÅ¼e teoretycznie wykonywaÄ‡ siÄ™ w nieskoÅ„czonoÅ›Ä‡ .
Czy zaproponowany algorytm moÅ¼na zastosowaÄ‡ do wygenerowania ciÄ…gu rosnÄ…cego?

Tak, moÅ¼na zmodyfikowaÄ‡ algorytm tak, aby generowaÅ‚ liczby w sposÃ³b Å›ciÅ›le rosnÄ…cy, na przykÅ‚ad dodajÄ…c inkrementacjÄ™ zamiast losowania do momentu speÅ‚nienia warunku .


Lab3:


1.RÃ³Å¼nica pomiÄ™dzy klasÄ… a obiektem klasy:

Klasa to szablon, definicja, lub typ, ktÃ³ry opisuje wÅ‚aÅ›ciwoÅ›ci i zachowanie obiektÃ³w (np. pola, metody).
Obiekt klasy to instancja klasy, czyli konkretny egzemplarz, ktÃ³ry jest tworzony na podstawie klasy.

2.SkÅ‚adniki klasy: SkÅ‚adnikami klasy mogÄ… byÄ‡:

Pola (atrybuty): Zmienna, ktÃ³ra przechowuje dane obiektu.
Metody (funkcje czÅ‚onkowskie): Operacje lub akcje, ktÃ³re obiekt moÅ¼e wykonywaÄ‡.
Konstruktory: Specjalne metody, ktÃ³re inicjalizujÄ… obiekt.
Destruktory: Metody, ktÃ³re wykonujÄ… akcje przy usuwaniu obiektu.

3.Proces tworzenia obiektu: Tworzenie obiektu klasy polega na:

Zadeklarowaniu zmiennej, ktÃ³ra jest instancjÄ… klasy.
UÅ¼yciu konstruktora, aby przypisaÄ‡ poczÄ…tkowe wartoÅ›ci do atrybutÃ³w obiektu.
Obiekt jest tworzony w pamiÄ™ci na stosie lub stercie, w zaleÅ¼noÅ›ci od sposobu deklaracji.

4.Metoda uruchamiajÄ…ca siÄ™ przy usuwaniu obiektu:

Destruktor to metoda, ktÃ³ra uruchamia siÄ™ automatycznie, gdy obiekt jest usuwany z pamiÄ™ci. SÅ‚uÅ¼y do zwalniania zasobÃ³w zajmowanych przez obiekt, np. pamiÄ™ci. W jÄ™zyku C++ jest to metoda o nazwie klasy poprzedzonej tyldÄ… (~), np. ~Klasa().

Odp do listingow: 

Listing 3.2
Wiersz 10 â€“ Jakie wartoÅ›ci moÅ¼na podstawiÄ‡ pod zmiennÄ… nazwa?

MoÅ¼na przypisaÄ‡ dowolny ciÄ…g znakÃ³w (std::string). DomyÅ›lnÄ… wartoÅ›ciÄ… jest "?" .
Wiersz 11 â€“ Czy w main() moÅ¼na podstawiÄ‡ obiektKlasy.bok1 = 3?

Nie, poniewaÅ¼ bok1 jest prywatnym polem klasy Prostokat .
Wiersz 15 â€“ JakÄ… wartoÅ›Ä‡ zwraca metoda czyPoprawny?

Zwraca true, jeÅ›li dÅ‚ugoÅ›ci bokÃ³w sÄ… dodatnie, w przeciwnym razie false .
Wiersz 16 â€“ Czy moÅ¼na wywoÅ‚aÄ‡ obiektKlasy.obliczObwod() w main()?

Nie, obliczObwod() jest metodÄ… prywatnÄ… .
Wiersz 20 â€“ Efekt uÅ¼ycia domyÅ›lnych wartoÅ›ci argumentÃ³w metody

JeÅ›li obiekt zostanie utworzony jako Prostokat p;, wartoÅ›ci domyÅ›lne to "?", 1.0, 2.0 .
Wiersz 15 i 22 â€“ Czym rÃ³Å¼niÄ… siÄ™ metody?

czyPoprawny(double, double) sprawdza podane wartoÅ›ci, natomiast czyPoprawny() zwraca stan obiektu. Jest to przeciÄ…Å¼enie metod .
Wiersz 23 â€“ Co zwraca metoda?

const std::string& â€“ zwraca referencjÄ™ na nazwa .
Wiersz 28 â€“ Co oznacza std::? Czy jest konieczne?

std:: odnosi siÄ™ do przestrzeni nazw standardowej biblioteki C++. MoÅ¼na go pominÄ…Ä‡, jeÅ›li wczeÅ›niej uÅ¼yto using namespace std; .
Listing 3.3
Wiersz 1 â€“ Co oznacza Prostokat::?

To operator zakresu, ktÃ³ry okreÅ›la, Å¼e metoda czyPoprawny() naleÅ¼y do klasy Prostokat .
Wiersz 2 â€“ SkÄ…d bierze siÄ™ zwracana wartoÅ›Ä‡?

czyPoprawny() zwraca wartoÅ›Ä‡ zmiennej poprawny, ktÃ³ra zostaÅ‚a ustawiona podczas tworzenia obiektu .
Listing 3.6
Wiersz 1 â€“ Co oznacza :nazwa(n)?

To lista inicjalizacyjna, ktÃ³ra przypisuje n do nazwa. MoÅ¼na to zastÄ…piÄ‡ przypisaniem w { }, ale lista inicjalizacyjna jest preferowana dla const i referencji .
Wiersz 11 â€“ JakÄ… wartoÅ›Ä‡ bÄ™dzie miaÅ‚o bok2?

JeÅ›li bok1 i bok2 sÄ… niepoprawne, zostanÄ… ustawione na 0 .
Listing 3.7
Czy std:: jest konieczne?
Tylko jeÅ›li wczeÅ›niej nie uÅ¼yto using namespace std; .
Listing 3.12
Jak dziaÅ‚a metoda? Dlaczego moÅ¼na wywoÅ‚ywaÄ‡ metody prywatne?
Metoda zmienBoki() wywoÅ‚uje czyPoprawny(), obliczObwod() i obliczPole(), ktÃ³re sÄ… prywatne. MoÅ¼na to zrobiÄ‡, poniewaÅ¼ sÄ… czÄ™Å›ciÄ… tej samej klasy .
Listing 3.13
Wiersze 5, 6, 9 â€“ Co robi std::to_string()?
Konwertuje liczby (double) na std::string .
Listing 3.14
Wiersze 14-16 â€“ Jak uzyskaÄ‡ dostÄ™p do pola/metody obiektu?

Za pomocÄ… operatora . np. p2.podajObwod() .
Wiersz 9 â€“ Jakie wartoÅ›ci przyjmuje konstruktor?

CiÄ…g znakÃ³w n oraz dwie liczby zmiennoprzecinkowe a i b .
Wiersz 13 â€“ Co robi precision na cout?

Ustawia liczbÄ™ cyfr po przecinku .
Wiersze 14-16 â€“ Dlaczego precision nie dziaÅ‚a tu?

to_string() formatuje liczby niezaleÅ¼nie od cout.precision() .
Wiersze 21-25 â€“ Ile instrukcji jest w tych wierszach?

Cztery wywoÅ‚ania metod na p2 .
Czy moÅ¼na zmieniÄ‡ p1.nazwa = "Inna nazwa"?

Nie, poniewaÅ¼ nazwa jest prywatna .
Czy destruktor siÄ™ uruchamia?

Tak, poniewaÅ¼ kaÅ¼dy obiekt ma automatycznie wywoÅ‚any destruktor przy koÅ„cu zasiÄ™gu .
Listing 3.15
Co oznacza â€pÄ…czkujÄ…cyâ€ obiekt klasy Organizm?

paczkujacy() zwraca true, jeÅ›li organizm zjadÅ‚ wiÄ™cej niÅ¼ kosztPotomka .
Wiersze 4-5 â€“ Efekt const?

limitPosilkow i kosztPotomka nie mogÄ… byÄ‡ zmieniane po inicjalizacji .
Wiersze 8-9 â€“ Dlaczego licznikZycia i licznikPosilkow nie mogÄ… byÄ‡ const?

PoniewaÅ¼ zmieniajÄ… swojÄ… wartoÅ›Ä‡ w trakcie symulacji .
Wiersz 16 â€“ Co oznacza const w metodzie?

Metoda nie moÅ¼e zmieniaÄ‡ pÃ³l obiektu .
KtÃ³re metody moÅ¼na wywoÅ‚aÄ‡ na obiekcie Organizm?

Wszystkie publiczne metody .
KtÃ³re metody moÅ¼na wywoÅ‚aÄ‡ na const Organizm?

Tylko metody oznaczone jako const .
Czy moÅ¼na utworzyÄ‡ Organizm organizmPusty;?

Nie, poniewaÅ¼ nie ma domyÅ›lnego konstruktora .
Listing 3.16-3.22
Co robi metoda posilek?

ZwiÄ™ksza licznikPosilkow .
Co robi metoda potomek?

Sprawdza, czy organizm moÅ¼e siÄ™ rozmnoÅ¼yÄ‡ .
Co robi metoda krokSymulacji?

Zmniejsza licznikZycia, jeÅ›li organizm Å¼yje .
Co robi funkcja drukujOrganizm()?

WyÅ›wietla stan organizmu .
Jaki konstruktor zostaÅ‚ uÅ¼yty w Listing 3.22?

Konstruktor z trzema parametrami .
Na czym polega test niezaleÅ¼noÅ›ci obiektÃ³w?

Sprawdza, czy zmiana jednego obiektu nie wpÅ‚ywa na inny .
Na czym polega test symulacji?

Sprawdza dziaÅ‚anie organizmu w ekosystemie .


Lab4:


1.Typ wyliczeniowy w jÄ™zyku C++: Typ wyliczeniowy (ang. enum) to specjalny typ danych, ktÃ³ry pozwala na tworzenie zmiennych, ktÃ³re mogÄ… przyjmowaÄ‡ jednÄ… z kilku ustalonych, nazwanych wartoÅ›ci. DziÄ™ki temu kod jest bardziej czytelny i Å‚atwiejszy do utrzymania.

enum DzieÅ„Tygodnia { PoniedziaÅ‚ek, Wtorek, Åšroda, Czwartek, PiÄ…tek, Sobota, Niedziela };

DzieÅ„Tygodnia dzisiaj = Åšroda;

if (dzisiaj == Åšroda) {
    std::cout << "DziÅ› jest Å›roda!" << std::endl;
}
W tym przykÅ‚adzie typ DzieÅ„Tygodnia definiuje dni tygodnia jako wartoÅ›ci wyliczeniowe. KaÅ¼dy z tych dni jest reprezentowany przez liczbÄ™ (np. PoniedziaÅ‚ek = 0, Wtorek = 1 itd.), ale dziÄ™ki nazwom, kod jest bardziej zrozumiaÅ‚y.

2.SkÅ‚adniki statyczne klasy: SkÅ‚adniki statyczne klasy to zmienne i metody, ktÃ³re sÄ… wspÃ³lne dla wszystkich obiektÃ³w tej klasy. Zamiast tworzyÄ‡ kopiÄ™ zmiennej w kaÅ¼dym obiekcie, zmienna statyczna jest jedna i wspÃ³Å‚dzielona przez wszystkie instancje klasy. Aby zadeklarowaÄ‡ zmiennÄ… lub metodÄ™ jako statycznÄ…, uÅ¼ywamy sÅ‚owa kluczowego static.

3.Wzorzec projektowy klasy: Wzorzec projektowy (ang. design pattern) to sprawdzone rozwiÄ…zanie okreÅ›lonego problemu w programowaniu obiektowym. Wzorce projektowe pomagajÄ… w tworzeniu elastycznych, Å‚atwych w utrzymaniu i rozszerzalnych aplikacji. SÄ… to zalecane metody organizacji kodu, ktÃ³re uÅ‚atwiajÄ… rozwiÄ…zywanie powszechnych problemÃ³w projektowych.

PrzykÅ‚ad: Wzorzec Singleton: Wzorzec Singleton zapewnia, Å¼e w danym czasie istnieje tylko jedna instancja danej klasy, a takÅ¼e umoÅ¼liwia dostÄ™p do tej instancji z dowolnego miejsca w programie.
W kodzie: 
class Singleton {
private:
    static Singleton* instancja;
    
    Singleton() {}  // Konstruktor prywatny

public:
    static Singleton* getInstancja() {
        if (instancja == nullptr) {
            instancja = new Singleton();
        }
        return instancja;
    }
};

Singleton* Singleton::instancja = nullptr;

int main() {
    Singleton* obj1 = Singleton::getInstancja();
    Singleton* obj2 = Singleton::getInstancja();
    
    if (obj1 == obj2) {
        std::cout << "To ta sama instancja!" << std::endl;
    }
}

Wzorzec Singleton gwarantuje, Å¼e obiekt klasy Singleton jest tworzony tylko raz, a wszystkie Å¼Ä…dania dostÄ™pu odnoszÄ… siÄ™ do tej samej instancji.

Odp do listingow:
Listing 4.2, wiersz 1 â†’ Typ wyliczeniowy RodzajMieszkanca przyjmuje wartoÅ›ci: GLON, GRZYB, BAKTERIA, PUSTKA, SCIANA, TRUP, NIEZNANE.

Listing 4.3, wiersze 5-12 â†’ Znajduje siÄ™ tu kilka instrukcji, takich jak deklaracje zmiennych i przypisania.

Listing 4.3, wiersze 14-28 â†’ Ten fragment zawiera wiÄ™cej instrukcji, w tym warunki i operacje logiczne.

Listing 4.3, wiersze 32-36 â†’ || to operator logiczny â€lubâ€ (logical OR). WartoÅ›Ä‡ wyraÅ¼enia jest true, jeÅ›li przynajmniej jeden operand jest true.

Listing 4.3, wiersze 30-37 â†’ Metoda poprawnyZnakNiszy sprawdza, czy dany znak naleÅ¼y do predefiniowanego zestawu znakÃ³w.

Listing 4.3, wiersze 38-41 â†’ Metoda zwraca wartoÅ›Ä‡ poprzez sprawdzenie zgodnoÅ›ci znaku.

Listing 4.3, wiersze 44, 44 â†’ SÄ… to konstruktory klasy. Jeden z nich uÅ¼ywa {} do inicjalizacji, a drugi dziaÅ‚a bez tego, poniewaÅ¼ moÅ¼e polegaÄ‡ na domyÅ›lnych konstruktorach skÅ‚adowych.

Listing 4.4, wiersze 1-5 â†’ Funkcja wyswietl nie zmienia trwale ustawieÅ„ symulacji, tylko je wyÅ›wietla.

Listing 4.4 â†’ Singleton UstawieniaSymulacji zapewnia, Å¼e istnieje tylko jeden obiekt tej klasy.

Listing 4.5 â†’ Klasa GeneratorLosowy uniemoÅ¼liwia tworzenie instancji dziÄ™ki prywatnemu konstruktorowi.

Listing 4.5, wiersz 6 â†’ MoÅ¼na uniknÄ…Ä‡ std:: poprzez using namespace std; lub using std::random_device;.

Listing 4.5, wiersz 17 â†’ typedef GeneratorLosowy GEN; definiuje skrÃ³t GEN, co upraszcza kod.

Listing 4.6 â†’ SkÅ‚adnik statyczny musi byÄ‡ zdefiniowany w pliku .cpp, poniewaÅ¼ jego deklaracja w .h nie wystarczy.

Listing 4.7, wiersze 4-8 â†’ Fragment kodu zamienia wartoÅ›ci, jeÅ›li min > max, zapewniajÄ…c poprawne dziaÅ‚anie funkcji losujÄ…cej.

Listing 4.9 â†’ Metoda losujOdZeraDo(int max) nie moÅ¼e wywoÅ‚aÄ‡ losujPomiedzy(0, max), poniewaÅ¼ losujPomiedzy wymaga dwÃ³ch argumentÃ³w o okreÅ›lonych typach.


Lab 5: 
1. RÃ³Å¼nica miÄ™dzy wskaÅºnikiem do staÅ‚ej a staÅ‚ym wskaÅºnikiem
WskaÅºnik do staÅ‚ej (const int *w1):

MoÅ¼na zmieniaÄ‡ adres (np. w1 = &a â†’ w1 = &b).

Nie moÅ¼na modyfikowaÄ‡ wartoÅ›ci (*w1 = 5 â†’ bÅ‚Ä…d).

const int a = 1;
w1 = &a; // OK
w1 = &b; // OK (zmiana adresu)
// *w1 = 5; // BÅ‚Ä…d!

StaÅ‚y wskaÅºnik (int *const w2 = &c):

Nie moÅ¼na zmieniaÄ‡ adresu (w2 = &d â†’ bÅ‚Ä…d).

MoÅ¼na modyfikowaÄ‡ wartoÅ›Ä‡ (*w2 = 5 â†’ OK).

PrzykÅ‚ad:
int c = 3;
int *const w2 = &c; // Inicjalizacja obowiÄ…zkowa
// w2 = &d; // BÅ‚Ä…d!
*w2 = 5;    // OK (zmiana wartoÅ›ci)
Czy moÅ¼na poÅ‚Ä…czyÄ‡ oba?
Tak: const int *const w3 = &a â€“ nie moÅ¼na zmieniÄ‡ ani adresu, ani wartoÅ›ci.

2. Cel przekazywania staÅ‚ej referencji/wskaÅºnika do metody
Dlaczego nie kopia?

WydajnoÅ›Ä‡: Dla duÅ¼ych obiektÃ³w (np. std::vector, bazy danych) kopia jest kosztowna.

BezpieczeÅ„stwo: StaÅ‚a referencja/wskaÅºnik (const) blokuje modyfikacje oryginaÅ‚u.

NiekopiowalnoÅ›Ä‡: NiektÃ³re obiekty (np. std::mutex, std::unique_ptr) nie mogÄ… byÄ‡ kopiowane.

Kopia wystarczy tylko gdy:

Obiekt jest maÅ‚y (kopiowanie jest tanie).

Metoda potrzebuje lokalnej modyfikowalnej kopii (np. do transformacji).

3. Polimorfizm statyczny (przykÅ‚ad: GeneratorLosowy)
Definicja: WybÃ³r metody w czasie kompilacji (np. przez przeciÄ…Å¼anie).

W klasie GeneratorLosowy:
static unsigned short losujPomiedzy(unsigned short, unsigned short); // Wersja 1
static long losujPomiedzy(long, long);                               // Wersja 2
DziaÅ‚anie:
GEN::losujPomiedzy(10, 20);    // WywoÅ‚a metodÄ™ dla `unsigned short`  
GEN::losujPomiedzy(100L, 200L); // WywoÅ‚a metodÄ™ dla `long`  
Zalety:

Brak narzutu (dynamiczne wiÄ…zanie np. funkcje wirtualne sÄ… wolniejsze).

Jednolity interfejs dla rÃ³Å¼nych typÃ³w (np. short, long).

Podsumowanie: Polimorfizm statyczny w C++ realizuje siÄ™ przez przeciÄ…Å¼anie metod/szablony, a GeneratorLosowy wykorzystuje go do generowania liczb dla rÃ³Å¼nych typÃ³w.

Odp do listingow:
Listing 5.1 â†’ Typy RodzajMieszkanca i Polozenie sÄ… prawdopodobnie zdefiniowane w osobnych plikach nagÅ‚Ã³wkowych.

Listing 5.1, wiersze 28-33 â†’ Argumenty metody sÄ… przekazywane przez referencjÄ™ (long & wiersz, long & kolumna), co umoÅ¼liwia ich modyfikacjÄ™ w funkcji.

Listing 5.2, wiersz 15 â†’ nullptr oznacza wskaÅºnik nie wskazujÄ…cy na Å¼adnÄ… pamiÄ™Ä‡ i zastÄ™puje NULL w C++11.

Listing 5.3, wiersze 4-5 â†’ static_cast<Polozenie>(GeneratorLosowy::losujPomiedzy(min, max)) konwertuje losowÄ… liczbÄ™ na wartoÅ›Ä‡ Polozenie.

Listing 5.4 â†’ auto automatycznie okreÅ›la typ zmiennej na podstawie przypisanej wartoÅ›ci.

Listing 5.5, linia 5 â†’ *elementWewnetrzny(polozenie) = rodzaj; oznacza przypisanie wartoÅ›ci do wskaÅºnika.

Listing 5.6 â†’ Metoda ktoJestSasiadem() zwraca RodzajMieszkanca przez dereferencjÄ™ wskaÅºnika.

Listing 5.7 â†’ Dwie pÄ™tle for iterujÄ… po tablicy 3x3, omijajÄ…c Å›rodek.

Listing 5.8, wiersze 8-9 â†’ JeÅ›li nie istnieje RodzajMieszkanca w sÄ…siedztwie, pÄ™tla while moÅ¼e siÄ™ nie zakoÅ„czyÄ‡.

Listing 5.9 â†’ Metoda zmienia indeksy macierzy 3x3 zgodnie z Polozenie, przesuwajÄ…c wiersz i kolumna.

Listing 5.10 â†’ static_cast<long> rzutuje unsigned int na long, aby umoÅ¼liwiÄ‡ operacje arytmetyczne.

Listing 5.9 i 5.10 â€“ polimorfizm?

Tak, poniewaÅ¼ metody zmienIdeksyWgPolozenia() sÄ… przeciÄ…Å¼one (polimorfizm statyczny).
Listing 5.12, wiersz 49 â€“ rzutowanie?

static_cast<Polozenie>(i); konwertuje int na Polozenie, aby uniknÄ…Ä‡ niejawnych konwersji.
Listing 5.12, wiersze 52-53 â†’ WywoÅ‚ano zmienIdeksyWgPolozenia(Polozenie, long&, long&), poniewaÅ¼ argumenty to long.

Lab6:
1. Czym jest dziedziczenie?
Dziedziczenie to mechanizm programowania obiektowego, ktÃ³ry pozwala na tworzenie nowych klas na podstawie juÅ¼ istniejÄ…cych. Klasa bazowa (rodzic) przekazuje swoje wÅ‚aÅ›ciwoÅ›ci i metody do klasy pochodnej (dziecko), co pozwala na ponowne wykorzystanie kodu i jego rozszerzanie bez koniecznoÅ›ci duplikacji.

2. Co siÄ™ dziedziczy, a co nie?
DziedziczÄ… siÄ™:

Pola (zmienne czÅ‚onkowskie) â€“ jeÅ›li sÄ… oznaczone jako public lub protected,

Metody â€“ mogÄ… byÄ‡ nadpisywane w klasach pochodnych,

WÅ‚aÅ›ciwoÅ›ci â€“ jeÅ›li nie sÄ… oznaczone jako private,

Konstruktor klasy bazowej moÅ¼e byÄ‡ wywoÅ‚any przez klasÄ™ pochodnÄ….

Nie dziedziczÄ… siÄ™:

Prywatne skÅ‚adowe (private) â€“ sÄ… dostÄ™pne tylko w obrÄ™bie klasy bazowej,

Konstruktory â€“ choÄ‡ moÅ¼na je wywoÅ‚ywaÄ‡ w klasach pochodnych, nie sÄ… one dziedziczone,

Destruktory â€“ kaÅ¼da klasa ma wÅ‚asny destruktor,

Operatory przypisania â€“ domyÅ›lnie nie sÄ… dziedziczone, ale moÅ¼na je przeciÄ…Å¼aÄ‡.

3. Jak sterowaÄ‡ widocznoÅ›ciÄ… skÅ‚adnikÃ³w?
WidocznoÅ›Ä‡ elementÃ³w w klasie bazowej wpÅ‚ywa na ich dostÄ™pnoÅ›Ä‡ w klasach pochodnych:

public â€“ dostÄ™pne wszÄ™dzie, takÅ¼e w klasach pochodnych,

protected â€“ dostÄ™pne w klasie bazowej i klasach dziedziczÄ…cych, ale nie na zewnÄ…trz,

private â€“ dostÄ™pne tylko w obrÄ™bie klasy bazowej.

Podczas dziedziczenia moÅ¼na takÅ¼e zmieniaÄ‡ poziom dostÄ™pu:

public dziedziczenie zachowuje dostÄ™pnoÅ›Ä‡ skÅ‚adnikÃ³w,

protected dziedziczenie sprawia, Å¼e publiczne skÅ‚adowe klasy bazowej stajÄ… siÄ™ protected w klasie pochodnej,

private dziedziczenie powoduje, Å¼e wszystkie publiczne i chronione skÅ‚adniki stajÄ… siÄ™ prywatne.

4. Jak utworzyÄ‡ metodÄ™ wirtualnÄ…?
Metoda wirtualna to metoda, ktÃ³rÄ… moÅ¼na nadpisaÄ‡ w klasie pochodnej. Aby jÄ… utworzyÄ‡ w C++, naleÅ¼y uÅ¼yÄ‡ sÅ‚owa kluczowego virtual:

class Bazowa {
public:
    virtual void Wyswietl() { std::cout << "Metoda z klasy bazowej"; }
};
W klasie pochodnej moÅ¼na jÄ… nadpisaÄ‡:

class Pochodna : public Bazowa {
public:
    void Wyswietl() override { std::cout << "Metoda z klasy pochodnej"; }
};
DziÄ™ki temu wywoÅ‚anie metody przez wskaÅºnik do klasy bazowej wywoÅ‚a metodÄ™ z klasy pochodnej.

5. Na czym polega polimorfizm dynamiczny?
Polimorfizm dynamiczny to zdolnoÅ›Ä‡ obiektÃ³w do wywoÅ‚ywania odpowiednich metod w zaleÅ¼noÅ›ci od rzeczywistego typu obiektu, a nie od typu wskaÅºnika lub referencji. Jest realizowany za pomocÄ… metod wirtualnych i tablicy wirtualnych funkcji (vtable).

PrzykÅ‚ad:

Bazowa* obiekt = new Pochodna();
obiekt->Wyswietl(); // WywoÅ‚a metodÄ™ z Pochodna, jeÅ›li Wyswietl() jest wirtualna.
DziÄ™ki temu moÅ¼na tworzyÄ‡ elastyczne i rozszerzalne programy bez koniecznoÅ›ci modyfikowania kodu bazowego.

Odp do listingow:
Listing 6.2, wiersz 4 â†’ SkÄ…d siÄ™ wziÄ™Å‚a metoda doTekstu w klasie Kwadrat?
Pochodzi z klasy bazowej Figura. Kwadrat dziedziczy doTekstu jako metodÄ™ wirtualnÄ… i moÅ¼e jÄ… przesÅ‚aniaÄ‡ (override).

Listing 6.2, wiersz 6 â†’ Dlaczego to nie zadziaÅ‚a?
PoniewaÅ¼ metoda doTekstu w klasie Figura moÅ¼e byÄ‡ czysto wirtualna (=0), a nie zostaÅ‚a zaimplementowana w Kwadrat, lub obiekt nie ma kontekstu dynamicznego (brak virtual).

Listing 6.3, wiersze 5â€“6 â†’ Jak dziaÅ‚a konstruktor klasy Kwadrat?
WywoÅ‚uje konstruktor klasy bazowej Figura z parametrem, nastÄ™pnie inicjalizuje wÅ‚asne pole bok.

Listing 6.6, wiersz 12 â†’ Po co jest znak &?
To referencja â€” przekazujemy obiekt Kwadrat przez referencjÄ™, by uniknÄ…Ä‡ kopiowania i umoÅ¼liwiÄ‡ polimorfizm.

Listing 6.7, wiersz 12 â†’ Czy moÅ¼na byÅ‚oby uÅ¼yÄ‡ tutaj pierwszej referencji?
Tak, ale jeÅ›li const Figura&, to tylko do metod const. W przeciwnym razie nie.

Listing 6.8, wiersze 5 i 6 â†’ Co oznacza =0?
To metoda czysto wirtualna â€“ klasa staje siÄ™ abstrakcyjna i nie moÅ¼na jej instancjonowaÄ‡.

Listing 6.10 â†’ Czy zamiast referencji moÅ¼na uÅ¼yÄ‡ wskaÅºnika?
Tak, referencjÄ™ Figura& moÅ¼na zastÄ…piÄ‡ Figura*, ale trzeba jawnie dereferencjonowaÄ‡.

Czy moÅ¼na utworzyÄ‡ obiekt klasy Mieszkaniec?
Nie, jeÅ›li zawiera metody czysto wirtualne (=0). Wtedy jest klasÄ… abstrakcyjnÄ….

Czy moÅ¼na utworzyÄ‡ obiekt klasy ZamiarMieszkanca?
Tak, jeÅ›li nie zawiera metod czysto wirtualnych.

Listing 6.11, wiersze 6 i 7 â†’ Co oznaczajÄ… â€= NICâ€ oraz â€= NIGDZIEâ€?
To inicjalizacja pÃ³l wartoÅ›ciami domyÅ›lnymi â€“ zapewnia, Å¼e obiekt ma okreÅ›lony stan poczÄ…tkowy.

Listing 6.12, wiersz 1 â†’ Czy class Sasiedztwo moÅ¼na zastÄ…piÄ‡ #include "sasiedztwo.h"?
Nie zawsze. class Sasiedztwo; to tzw. forward declaration. UÅ¼ywane, gdy wystarczy informacja o istnieniu klasy. #include jest potrzebny, jeÅ›li korzystasz z jej definicji.

Listing 6.12, wiersz 13 â†’ Jak nazywa siÄ™ ta metoda?
To konstruktor klasy, nosi nazwÄ™ klasy Sasiedztwo.

Listing 6.15, wiersz 15 â†’ Co powoduje sÅ‚owo final?
Oznacza, Å¼e metoda nie moÅ¼e byÄ‡ dalej przesÅ‚aniana (override) w klasach pochodnych.

Listing 6.12 â†’ KtÃ³re metody sÄ… abstrakcyjne?
Wszystkie oznaczone =0, czyli np. opis() = 0; lub dzialaj() = 0; w klasach bazowych.


Lab7:

PrzeciÄ…Å¼enie operatora przypisania (operator=) w klasie Nisza przedstawione w listingu 7.14 to przykÅ‚ad tzw. "przypisania przez zamianÄ™". Jest to prosty i bezpieczny sposÃ³b na przeciÄ…Å¼enie operatora przypisania, szczegÃ³lnie gdy mamy do czynienia z zasobami dynamicznymi (np. wskaÅºnikami), ktÃ³re wymagajÄ… odpowiedniego zarzÄ…dzania. PoniÅ¼ej krok po kroku, jak dziaÅ‚a ta metoda:
Nisza &Nisza::operator=(Nisza &innaNisza) {
    Mieszkaniec * tmp = lokator;
    lokator = innaNisza.lokator;
    innaNisza.lokator = tmp;
    return *this;
}
WyjaÅ›nienie dziaÅ‚ania:
Mieszkaniec * tmp = lokator;
Zapisujemy aktualnego lokatora tego obiektu (this) do tymczasowej zmiennej tmp. To jest zabezpieczenie przed utratÄ… danych.

lokator = innaNisza.lokator;
Przypisujemy wskaÅºnik z innego obiektu (innaNisza) do bieÅ¼Ä…cego obiektu (this). Teraz this->lokator wskazuje na tego samego mieszkaÅ„ca, co innaNisza->lokator.

innaNisza.lokator = tmp;
Do obiektu innaNisza wstawiamy naszego wczeÅ›niejszego lokatora. Czyli oba obiekty "zamieniajÄ… siÄ™" mieszkaÅ„cami.

return *this;
Zwracamy referencjÄ™ do aktualnego obiektu, co pozwala na Å‚aÅ„cuchowe przypisania typu a = b = c;.

Zalety tego podejÅ›cia:
Bezpieczne zarzÄ…dzanie zasobami â€“ nie ma potrzeby rÄ™cznego zwalniania pamiÄ™ci ani kopiowania mieszkaÅ„ca.

EfektywnoÅ›Ä‡ â€“ tylko wskaÅºniki sÄ… zamieniane, nie ma gÅ‚Ä™bokiej kopii.

Brak wyciekÃ³w pamiÄ™ci, jeÅ›li pozostaÅ‚e elementy klasy sÄ… dobrze zaimplementowane (np. destruktor).

Lab9:
1. Na czym polega polimorfizm statyczny?
Polimorfizm statyczny (kompilacyjny) polega na wiÄ…zaniu wywoÅ‚ania funkcji z jej definicjÄ… w czasie kompilacji. PrzykÅ‚ady to:

PrzeciÄ…Å¼anie funkcji (overloading),

Szablony (templates),

PrzeciÄ…Å¼anie operatorÃ³w.

2. Na czym polega polimorfizm dynamiczny?
Polimorfizm dynamiczny (runtime) polega na wywoÅ‚ywaniu odpowiedniej wersji metody w zaleÅ¼noÅ›ci od typu obiektu w czasie wykonywania programu. Wymaga uÅ¼ycia wskaÅºnikÃ³w lub referencji do klas bazowych oraz sÅ‚owa kluczowego virtual:

class Base { public: virtual void foo(); };
class Derived : public Base { public: void foo() override; };
3. Czy w jÄ™zyku C++ jest moÅ¼liwe poÅ‚Ä…czenie polimorfizmu dynamicznego i statycznego?
Tak, C++ pozwala Å‚Ä…czyÄ‡ oba rodzaje polimorfizmu w jednym programie. MoÅ¼na mieÄ‡ klasy z metodami virtual (dynamiczny) i jednoczeÅ›nie uÅ¼ywaÄ‡ np. szablonÃ³w lub przeciÄ…Å¼enia funkcji (statyczny).

4. Czy mechanizm wartoÅ›ci domyÅ›lnych argumentÃ³w metod zalicza siÄ™ do polimorfizmu?
Nie. DomyÅ›lne argumenty nie sÄ… polimorfizmem â€” to tylko uÅ‚atwienie skÅ‚adniowe na etapie kompilacji. Nie wpÅ‚ywajÄ… na wybÃ³r przeciÄ…Å¼onej wersji metody ani nie zmieniajÄ… zachowania w czasie wykonywania.

5. Czy polimorfizm statyczny siÄ™ dziedziczy?
Nie w sensie klasycznym. PrzeciÄ…Å¼anie funkcji nie jest dziedziczone automatycznie â€” trzeba jawnie udostÄ™pniÄ‡ przeciÄ…Å¼one wersje z klasy bazowej (np. za pomocÄ… using), Å¼eby byÅ‚y dostÄ™pne w klasie pochodnej.

6. Czy argumenty domyÅ›lne siÄ™ dziedziczy?
Argumenty domyÅ›lne nie sÄ… dziedziczone. JeÅ›li metoda z klasy bazowej ma domyÅ›lne argumenty, to w klasie pochodnej naleÅ¼y je ponownie zadeklarowaÄ‡, jeÅ›li chcemy je tam rÃ³wnieÅ¼ mieÄ‡.

7. Co siÄ™ dzieje, gdy istnieje juÅ¼ polimorfizm, ale usunie siÄ™ sÅ‚owo virtual?
UsuniÄ™cie virtual powoduje, Å¼e przestaje dziaÅ‚aÄ‡ mechanizm dynamicznego wiÄ…zania. WywoÅ‚ania metod bÄ™dÄ… rozwiÄ…zywane statycznie (wg typu wskaÅºnika), co moÅ¼e prowadziÄ‡ do bÅ‚Ä™dÃ³w (np. metoda klasy pochodnej nie zostanie wywoÅ‚ana przez wskaÅºnik do klasy bazowej).

8. Po co sÄ… te â€polimorfizmyâ€?
Polimorfizm uÅ‚atwia projektowanie elastycznego i rozszerzalnego kodu:

Statyczny â€“ zwiÄ™ksza czytelnoÅ›Ä‡ i umoÅ¼liwia wielokrotne uÅ¼ycie kodu (np. szablony).

Dynamiczny â€“ pozwala na programowanie obiektowe, gdzie moÅ¼na traktowaÄ‡ rÃ³Å¼ne obiekty w jednolity sposÃ³b (np. lista wskaÅºnikÃ³w do klasy bazowej).

9. W jaki sposÃ³b w jÄ™zyku C++ pobiera siÄ™ i zwalnia pamiÄ™Ä‡?

Pobieranie: new

int* ptr = new int;
Zwalnianie: delete

delete ptr;
Dla tablic:

int* arr = new int[10];
delete[] arr;
Od C++11 moÅ¼na takÅ¼e uÅ¼ywaÄ‡ inteligentnych wskaÅºnikÃ³w (std::unique_ptr, std::shared_ptr), ktÃ³re automatycznie zarzÄ…dzajÄ… pamiÄ™ciÄ….

Listing 9.1:
Czy rozmiar zmiennej wskaÅºnikowej zaleÅ¼y od typu na jaki ten wskaÅºnik pokazuje?
Nie, rozmiar zmiennej wskaÅºnikowej nie zaleÅ¼y od typu, na jaki ten wskaÅºnik pokazuje.

Listing 9.2:
1. Wiersz 11: delete wskInt1D; â€” Jaki byÅ‚by efekt, gdyby tego wiersza nie byÅ‚o?
JeÅ›li nie wywoÅ‚alibyÅ›my delete, to:

â¡ï¸ Zmienna wskInt1D nadal wskazywaÅ‚aby na zaalokowanÄ… dynamicznie pamiÄ™Ä‡ (new int), ale ta pamiÄ™Ä‡ nigdy nie zostaÅ‚aby zwolniona.
â¡ï¸ To prowadzi do wycieku pamiÄ™ci (memory leak) â€“ pamiÄ™Ä‡ zostaÅ‚aby zarezerwowana na czas dziaÅ‚ania programu, ale program juÅ¼ by z niej nie korzystaÅ‚ i nie mÃ³gÅ‚ jej odzyskaÄ‡.

ğŸ”´ Skutek:

Dla maÅ‚ych programÃ³w: brak widocznych problemÃ³w.

Dla wiÄ™kszych (np. z wieloma alokacjami w pÄ™tli): wzrost zuÅ¼ycia pamiÄ™ci, spowolnienia, a nawet awarie (brak pamiÄ™ci).

2. Wiersze 5 i 7: Po co jest znak *?
Znak * w tych miejscach sÅ‚uÅ¼y do dereferencji wskaÅºnika, czyli:

*wskInt1D = 5; â€“ zapisanie wartoÅ›ci 5 do miejsca w pamiÄ™ci, na ktÃ³re wskazuje wskaÅºnik.

*wskInt1D + 3 â€“ odczytanie tej wartoÅ›ci i dodanie 3 do niej.

ğŸ“Œ Bez *, operowalibyÅ›my na adresie, nie na zawartoÅ›ci!

3. Co oznacza zapis: int ** wskInt2D = nullptr;?
To oznacza:

â¡ï¸ wskInt2D to wskaÅºnik na wskaÅºnik typu int (czyli: int**).
â¡ï¸ Inaczej: zmienna wskInt2D przechowuje adres innego wskaÅºnika, ktÃ³ry z kolei przechowuje adres zmiennej typu int.

ğŸ“Œ Jest to przydatne np. przy dynamicznych tablicach 2D:

int** tablica = new int*[wiersze];
for(int i = 0; i < wiersze; ++i)
    tablica[i] = new int[kolumny];
â¡ï¸ Przypisanie nullptr oznacza, Å¼e wskInt2D na razie nie wskazuje na Å¼aden obiekt (jest "pusty").

Listing 9.3:
1. Wiersz 4: wskInt1D = new int[3]; â†’ Ile pamiÄ™ci zostanie zalokowane?
Zostanie zaalokowana pamiÄ™Ä‡ na 3 elementy typu int.

ğŸ“Œ JeÅ›li sizeof(int) == 4 bajty (typowe na wiÄ™kszoÅ›ci systemÃ³w), to:

â¡ï¸ 3 Ã— 4 bajty = 12 bajtÃ³w zostanie przydzielone dynamicznie.

2. Wiersze 7 i 11 â†’ Co powoduje operator +?
Operator + w kontekÅ›cie wskaÅºnikÃ³w przesuwa wskaÅºnik o podanÄ… liczbÄ™ elementÃ³w (nie bajtÃ³w):

Wiersz 7:
*(wskInt1D + 1) = 5;
â¡ï¸ Oznacza: przesuÅ„ wskaÅºnik o 1 element typu int (czyli o 4 bajty) i zapisz tam 5.
To rÃ³wnowaÅ¼ne z: wskInt1D[1] = 5;

Wiersz 11:
*(wskInt1D + 2)
â¡ï¸ Oznacza: odczytaj wartoÅ›Ä‡ trzeciego elementu tablicy (wskInt1D[2]).

ğŸŸ¦ PodsumowujÄ…c: operator + przy wskaÅºnikach wykonuje przesuniÄ™cie o N * sizeof(typ), zaleÅ¼nie od typu, na jaki wskazuje wskaÅºnik.

3. Wiersze 15 i 17 â†’ Co powoduje operator ++?
Operator ++ przesuwa wskaÅºnik do kolejnego elementu tablicy:

PrzykÅ‚ad:
iter++;  // przesuniÄ™cie wskaÅºnika iter z wskInt1D[0] -> wskInt1D[1]
ğŸ“Œ W kontekÅ›cie wskaÅºnikÃ³w oznacza: dodaj 1 do adresu, ale w jednostce â€rozmiar typuâ€, np. dla int o 4 bajty.

ğŸŸ¢ To pozwala na iterowanie po tablicy dynamicznej bez uÅ¼ycia indeksÃ³w.

Listing 9.4:
 1. Dlaczego lokowanie pamiÄ™ci odbywa siÄ™ dwuetapowo?
Alokacja pamiÄ™ci w wierszu:

wskInt2D = new int*[w];     // Etap 1
tworzy tablicÄ™ wskaÅºnikÃ³w â€“ kaÅ¼dy wskaÅºnik bÄ™dzie pÃ³Åºniej wskazywaÄ‡ na jeden wiersz.

A nastÄ™pnie:

for(int i=0; i<w; i++)
    wskInt2D[i] = new int(k);   // Etap 2
alokuje oddzielnie pamiÄ™Ä‡ dla kaÅ¼dego wiersza (czyli tablicÄ™ kolumn).

ğŸ“Œ Dlaczego tak:
C++ nie ma wbudowanego typu "tablica 2D dynamiczna" â€“ trzeba to zrobiÄ‡ rÄ™cznie.

Alokujemy najpierw â€kontenerâ€ wskaÅºnikÃ³w (1D), a potem podÅ‚Ä…czamy do nich â€podtabliceâ€ (drugie wymiary).

ğŸ”¹ 2. Dlaczego zwalnianie pamiÄ™ci odbywa siÄ™ dwuetapowo?
Wiersz 20:

for(int i=0; i<k; i++) delete [] wskInt2D[i]; 
Najpierw trzeba usunÄ…Ä‡ kaÅ¼dy wiersz (czyli podtablicÄ™), bo kaÅ¼dy wskInt2D[i] wskazuje na osobno zaalokowanÄ… tablicÄ™ int[k].

Potem:

delete [] wskInt2D;
zwalniamy pamiÄ™Ä‡ na tablicÄ™ wskaÅºnikÃ³w.

ğŸ“Œ Dlaczego dwuetapowo:
KaÅ¼dy rzÄ…d jest osobno zaalokowany â†’ trzeba go osobno zwolniÄ‡.

JeÅ›li pominiesz pierwszy krok, to wycieknÄ… caÅ‚e wiersze (memory leak).


3. Ilustracja: jak wyglÄ…da pamiÄ™Ä‡ w tablicy 2D (dla w=3, k=4)

wskInt2D ---> +-------+       +--> [0][0] [0][1] [0][2] [0][3]
              |   *   |------>+     (wartoÅ›ci: 0+0, 0+1, ...)
              +-------+       +--> [1][0] [1][1] [1][2] [1][3]
              |   *   |------>+     (wartoÅ›ci: 1+0, 1+1, ...)
              +-------+       +--> [2][0] [2][1] [2][2] [2][3]
              |   *   |------>+     (wartoÅ›ci: 2+0, 2+1, ...)
              +-------+
wskInt2D to wskaÅºnik na tablicÄ™ 3 wskaÅºnikÃ³w (int*)

KaÅ¼dy z tych wskaÅºnikÃ³w pokazuje na oddzielnÄ… tablicÄ™ int[4]

Listing 9.5:
ğŸ”¹ 1. Wiersze 5 i 6 â€“ Dlaczego to nie zadziaÅ‚a?

// int & refInt = new int;   // âŒ
// int & refInt = 4;         // âŒ
âŒ Wiersz 5: int & refInt = new int;
new int zwraca wskaÅºnik (int*), a nie referencjÄ™.

PrÃ³bujesz przypisaÄ‡ wskaÅºnik do referencji, co jest niespÃ³jne typowo.

ğŸ“› BÅ‚Ä…d kompilacji: niezgodnoÅ›Ä‡ typÃ³w â€” nie moÅ¼na przypisaÄ‡ int* do int&.

âŒ Wiersz 6: int & refInt = 4;
4 to literaÅ‚ liczbowy, niezmienny â€” nie moÅ¼na zrobiÄ‡ referencji do tymczasowego literalnego int, chyba Å¼e const int&.

âœ… Poprawna wersja:


const int & ref = 4; // dozwolone, bo to const-referencja
ğŸ”¹ 2. Wiersz 14 â€“ Co siÄ™ tutaj dzieje?

refInt = b;
ğŸ‘‰ refInt jest referencjÄ… do a (z linii 11).
WiÄ™c to nie znaczy: "refInt zaczyna wskazywaÄ‡ na b".

To znaczy:
â¡ï¸ WartoÅ›Ä‡ b zostaje przypisana do a przez refInt.

Bo refInt to alias zmiennej a, wiÄ™c przypisujÄ…c do niego, modyfikujesz a, a nie zmieniasz powiÄ…zania referencji.

ğŸŸ¢ Po tej linii: a == 5, b == 5.

ğŸ”¹ 3. Wiersze 14 vs 24 â€“ Jaka jest rÃ³Å¼nica?

refInt = b;      // Wiersz 14
wskInt = &B;     // Wiersz 24
Linia	Typ	Co siÄ™ dzieje
14	Referencja	Przypisanie wartoÅ›ci b do a (bo refInt to a)
24	WskaÅºnik	Zmiana wskaÅºnika wskInt, by teraz wskazywaÅ‚ na B

ğŸŸ¡ Kluczowa rÃ³Å¼nica:

Referencja jest aliasem â€“ nie moÅ¼na jej â€przeÅ‚Ä…czyÄ‡â€ na innÄ… zmiennÄ….

WskaÅºnik to zmienna â€“ moÅ¼esz go dowolnie przekierowywaÄ‡ (wsk = &innyObiekt).

ğŸ”¹ 4. Czy rozmiar referencji zaleÅ¼y od typu? (czy to pytanie ma sens?)

sizeof(int &)       // linia 31
sizeof(refInt)      // linia 32
sizeof(Glon &)      // linia 33
sizeof(refGlon)     // linia 34
âœ… Takie pytanie ma sens â€“ technicznie, ale:
sizeof(refInt) = sizeof(int)

sizeof(refGlon) = sizeof(Glon)

ğŸ“Œ Dlaczego?
Bo referencja nie ma rozmiaru jako osobna struktura â€” to tylko alias istniejÄ…cej zmiennej.
Nie istnieje fizycznie jako zmienna â€” kompilator zamienia uÅ¼ycie referencji na bezpoÅ›redni dostÄ™p do oryginaÅ‚u.

ğŸŸ¡ Zatem:

â¡ï¸ sizeof(ref) = sizeof(typ, na ktÃ³ry wskazuje)
â¡ï¸ Ale sizeof(int&) jest poprawny skÅ‚adniowo, choÄ‡ to tylko alias do sizeof(int)

Lab10:
1. Czym rÃ³Å¼ni siÄ™ wektor od â€zwykÅ‚ejâ€ tablicy dynamicznej?
Cecha	std::vector	Tablica dynamiczna (new[])
ZarzÄ…dzanie pamiÄ™ciÄ…	Automatyczne (RAII)	RÄ™czne (trzeba uÅ¼yÄ‡ delete[])
Rozmiar	Dynamicznie roÅ›nie	StaÅ‚y po alokacji
BezpieczeÅ„stwo	Ma metody (np. .at()) z kontrolÄ… zakresu	Brak kontroli zakresu
FunkcjonalnoÅ›Ä‡	Posiada wiele metod (push_back, size, clear)	Tylko indeksowanie
PrzenoszalnoÅ›Ä‡	Preferowana w nowoczesnym C++	CzÄ™Å›ciej uÅ¼ywana w starszym kodzie

2. Czym rÃ³Å¼ni siÄ™ wektor od zbioru (std::set)?
Cecha	std::vector	std::set
KolejnoÅ›Ä‡	Zachowuje kolejnoÅ›Ä‡ dodania	Przechowuje dane posortowane
PowtarzalnoÅ›Ä‡	Pozwala na duplikaty	Nie pozwala na duplikaty
DostÄ™p	Indeksowany (np. vec[i])	Nie ma indeksÃ³w
Implementacja	CiÄ…gÅ‚a tablica	Struktura drzewa (RB-tree)

3. Czym rÃ³Å¼ni siÄ™ mapa (std::map) od wektora?
Cecha	std::vector	std::map
Typ danych	Pojedyncze elementy	Klucz-wartoÅ›Ä‡ (key-value)
DostÄ™p	Indeksy liczbowe (vec[i])	Klucze dowolnego typu (map[key])
KolejnoÅ›Ä‡	Zachowuje kolejnoÅ›Ä‡	Sortuje po kluczu
Wyszukiwanie	Wymaga przeszukania liniowego	Wydajne (log(n)) przez drzewo

4. Co ma wspÃ³lnego zbiÃ³r z mapÄ…?
Oba sÄ… strukturami opartymi na drzewie binarnym (RB-tree).

Oba sÄ… uporzÄ…dkowane kontenery STL.

Oba nie dopuszczajÄ… duplikatÃ³w (mapa nie pozwala na powtarzajÄ…ce siÄ™ klucze, a zbiÃ³r â€“ na powtarzajÄ…ce siÄ™ elementy).

Oba oferujÄ… szybkie operacje insert, erase, find â€“ o zÅ‚oÅ¼onoÅ›ci O(log n).

5. Jak nazywa siÄ™ specjalny wskaÅºnik przewidziany do pracy z kontenerami?
âœ… Iterator â€“ specjalny obiekt, ktÃ³ry dziaÅ‚a jak wskaÅºnik, ale przystosowany do pracy z kontenerami STL. Pozwala na dostÄ™p, poruszanie siÄ™ i modyfikacjÄ™ elementÃ³w.

6. W jaki sposÃ³b przeciÄ…Å¼a siÄ™ operator >>?
PrzeciÄ…Å¼enie operatora >> (np. do wczytywania z std::cin) realizuje siÄ™ jako funkcja zewnÄ™trzna (nie czÅ‚onkowska), np.:


std::istream& operator>>(std::istream& in, MyClass& obj) {
    in >> obj.a >> obj.b;
    return in;
}
7. W jaki sposÃ³b przeciÄ…Å¼a siÄ™ operator <<?
Podobnie jak >>, operator << (np. do std::cout) przeciÄ…Å¼a siÄ™ jako funkcja zewnÄ™trzna:


std::ostream& operator<<(std::ostream& out, const MyClass& obj) {
    out << obj.a << " " << obj.b;
    return out;
}
8. W jaki sposÃ³b przeciÄ…Å¼a siÄ™ operator ++?
MoÅ¼na przeciÄ…Å¼yÄ‡ wersjÄ™ preinkrementacyjnÄ… i postinkrementacyjnÄ…:


// Preinkrementacja (++obj)
MyClass& operator++() {
    ++a;
    return *this;
}

// Postinkrementacja (obj++)
MyClass operator++(int) {
    MyClass temp = *this;
    ++(*this);
    return temp;
}
9. W jaki sposÃ³b przeciÄ…Å¼a siÄ™ operator !?
Jest to operator jednoargumentowy, przeciÄ…Å¼any zwykle jako metoda:

bool MyClass::operator!() const {
    return a == 0; // dowolna logika
}

1. Listing 10.1, wiersze 5, 6, 7 i 8 â†’ Do czego sÅ‚uÅ¼y metoda push_back?
Metoda push_back sÅ‚uÅ¼y do dodawania nowego elementu na koniec wektora. W tym przypadku dodaje kolejne wartoÅ›ci 0, 1, 2, 3 do dynamicznej tablicy (wektora). DziÄ™ki temu wektor zwiÄ™ksza swÃ³j rozmiar i przechowuje te elementy.

2. Listing 10.1, wiersz 10 â†’ Do czego sÅ‚uÅ¼y metoda size?
Metoda size zwraca aktualnÄ… liczbÄ™ elementÃ³w przechowywanych w wektorze. W tym wierszu kodu jest uÅ¼ywana do wyÅ›wietlenia rozmiaru wektora, czyli ile elementÃ³w w nim jest.

3. Listing 10.1, wiersz 17 â†’ Jak dziaÅ‚a pÄ™tla for?
PÄ™tla for(double d : wektor) to tzw. pÄ™tla zakresowa (range-based for loop). Dla kaÅ¼dego elementu d w wektorze wektor wykonywana jest instrukcja w ciele pÄ™tli (w tym przypadku cout << d << " ";). Pozwala to na Å‚atwe przechodzenie po wszystkich elementach kolekcji bez uÅ¼ycia indeksÃ³w.

4. Listing 10.1, wiersz 21 â†’ Do czego sÅ‚uÅ¼y metoda resize?
Metoda resize zmienia rozmiar wektora. W tym wypadku wektor jest powiÄ™kszany do rozmiaru 12. JeÅ›li nowy rozmiar jest wiÄ™kszy niÅ¼ aktualny, nowe elementy sÄ… inicjalizowane domyÅ›lnÄ… wartoÅ›ciÄ… (dla typu double bÄ™dzie to 0.0). DziÄ™ki temu moÅ¼na pÃ³Åºniej bezpiecznie zapisywaÄ‡ dane pod nowymi indeksami.

5. Listing 10.1, wiersz 35 â†’ Dlaczego zostaÅ‚a uÅ¼yta referencja?
W pÄ™tli for(double & d : wektor) zmienna d jest referencjÄ… do elementu wektora, co oznacza, Å¼e modyfikacje na d wpÅ‚ywajÄ… bezpoÅ›rednio na elementy wektora. Gdyby d byÅ‚a zwykÅ‚Ä… zmiennÄ… (kopiÄ…), zmiany w pÄ™tli nie zmieniÅ‚yby elementÃ³w w wektorze.

6. Listing 10.1, wiersz 41 â†’ Do czego sÅ‚uÅ¼y metoda clear?
Metoda clear usuwa wszystkie elementy z wektora, czyli ustawia jego rozmiar na zero. Wektor pozostaje wciÄ…Å¼ gotowy do uÅ¼ycia, ale nie zawiera Å¼adnych elementÃ³w.

1. Listing 10.2, wiersz 7 â†’ SkÄ…d siÄ™ wziÄ…Å‚ GEN?
GEN to prawdopodobnie nazwa przestrzeni nazw (namespace) lub klasy, ktÃ³ra zawiera metodÄ™ losujOdZeraDo(int max). Jest to funkcja generujÄ…ca losowe liczby caÅ‚kowite od 0 do max (w tym przypadku do 20). Taka funkcja nie jest standardowÄ… funkcjÄ… C++, wiÄ™c najpewniej pochodzi z wczeÅ›niejszej czÄ™Å›ci projektu lub wÅ‚asnej biblioteki, ktÃ³rÄ… autor zadania uÅ¼ywa do generowania liczb losowych.

2. Listing 10.2, wiersz 14 â†’ Jak okreÅ›la siÄ™ zakres sortowania?
Zakres sortowania okreÅ›la siÄ™ przez podanie dwÃ³ch iteratorÃ³w:

wektor.begin() â€“ iterator wskazujÄ…cy na pierwszy element wektora,

wektor.end() â€“ iterator wskazujÄ…cy za ostatni element wektora.

Funkcja sort() sortuje elementy od iteratora begin() do iteratora end() (nie wÅ‚Ä…czajÄ…c elementu na end()), czyli caÅ‚y wektor.

1. Listing 10.3, wiersz 3 â†’ Do czego sÅ‚uÅ¼y metoda insert?
Metoda insert sÅ‚uÅ¼y do dodawania elementÃ³w do zbioru (kontenera set). JeÅ›li element juÅ¼ istnieje w zbiorze, to nie zostanie dodany ponownie â€” zbiÃ³r przechowuje tylko unikalne elementy.

2. Listing 10.3 â†’ W jaki sposÃ³b zostaÅ‚o pokazane, Å¼e zbiÃ³r nie powiela elementÃ³w?
W liniach 10-14 do zbioru wstawiane sÄ… elementy, z ktÃ³rych niektÃ³re (np. "Adam", "Ewa", "Maciek") sÄ… juÅ¼ wczeÅ›niej dodane. W wyniku wyÅ›wietlenia zawartoÅ›ci zbioru (w liniach 16-17 i dalej w pÄ™tli), widaÄ‡, Å¼e elementy te pojawiajÄ… siÄ™ tylko raz, co pokazuje, Å¼e set automatycznie odrzuca duplikaty.

3. Listing 10.3, wiersz 19 â†’ Jaka jest poczÄ…tkowa pozycja iteratora?
Iterator iter jest ustawiony na poczÄ…tek zbioru, czyli wskazuje na pierwszy element zbioru (imiona.begin()).

4. Listing 10.3, wiersz 20 â†’ Jak sprawdza siÄ™ czy iterator osiÄ…gnÄ…Å‚ ostatni element w kontenerze?
Sprawdza siÄ™ to porÃ³wnujÄ…c iterator iter z imiona.end(), ktÃ³ry wskazuje za ostatnim elementem zbioru. PÄ™tla dziaÅ‚a dopÃ³ki iter != imiona.end(). Gdy iter osiÄ…gnie end(), oznacza to, Å¼e przeszliÅ›my przez wszystkie elementy.

5. Listing 10.3, wiersz 22 â†’ Jak przesuwa siÄ™ iterator?
Iterator jest przesuwany na kolejny element za pomocÄ… operatora inkrementacji iter++.

1. Listing 10.4, wiersz 3 â†’ Jak definiuje siÄ™ obiekt klasy map?
Obiekt klasy map definiuje siÄ™ podajÄ…c dwa typy szablonu: typ klucza i typ wartoÅ›ci. W tym przypadku map<char,double> oznacza mapÄ™, ktÃ³ra przechowuje pary: klucz typu char i wartoÅ›Ä‡ typu double. Obiekt pomiary jest wiÄ™c sÅ‚ownikiem, gdzie do liter ('A', 'B', itd.) przypisane sÄ… liczby zmiennoprzecinkowe.

2. Listing 10.4, wiersze od 5 do 10 â†’ W jaki sposÃ³b umieszcza siÄ™ elementy w mapie?
Elementy umieszcza siÄ™ w mapie za pomocÄ… metody insert(), ktÃ³ra przyjmuje obiekt typu pair<klucz, wartoÅ›Ä‡>. W przykÅ‚adzie uÅ¼yto pair<char,double>, np. pair<char,double>('A', 20). Dodanie klucza, ktÃ³ry juÅ¼ istnieje, nie zmienia istniejÄ…cej wartoÅ›ci â€” wstawienie ('A',40) po wczeÅ›niejszym dodaniu ('A',20) nie zastÄ…pi wartoÅ›ci.

3. Listing 10.4, wiersz 14 â†’ W jaki sposÃ³b uzyskuje siÄ™ dostÄ™p do elementu mapy?
DostÄ™p do wartoÅ›ci pod danym kluczem uzyskuje siÄ™ za pomocÄ… operatora indeksowania [], np. pomiary[c]. Zwraca wartoÅ›Ä‡ powiÄ…zanÄ… z kluczem c. JeÅ›li klucz nie istnieje, operator [] doda go do mapy z domyÅ›lnÄ… wartoÅ›ciÄ… (dla typu double jest to 0.0).

4. Listing 10.4, wiersz 16 â†’ Do czego sÅ‚uÅ¼y metoda count?
Metoda count zwraca liczbÄ™ wystÄ…pieÅ„ danego klucza w mapie. PoniewaÅ¼ mapy przechowujÄ… unikalne klucze, wynik bÄ™dzie 0 (jeÅ›li klucza nie ma) lub 1 (jeÅ›li klucz jest obecny).

5. Listing 10.4, wiersz 18 â†’ Do czego sÅ‚uÅ¼y metoda erase?
Metoda erase usuwa element o podanym kluczu z mapy. W tym przypadku pomiary.erase('A') usuwa z mapy element o kluczu 'A'.

1. Listing 10.5, wiersze 1 i 2 â†’ Czy argumenty mogÄ… byÄ‡ przekazane jako referencje do staÅ‚ych?
Tak, argumenty mogÄ… i powinny byÄ‡ przekazane jako referencje do staÅ‚ych, czyli tak:

cpp
Skopiuj kod
ostream &operator<<(ostream &strumien, const Prostokat &prostokat)
Dlaczego?

ostream &strumien pozostaje jako referencja (bez const), bo chcemy zapisywaÄ‡ do strumienia.

Prostokat &prostokat powinno byÄ‡ const Prostokat &prostokat, poniewaÅ¼ operator << zwykle nie modyfikuje obiektu, a przyjÄ™cie referencji do staÅ‚ej pozwala na przekazywanie zarÃ³wno staÅ‚ych, jak i zmiennych obiektÃ³w, zwiÄ™kszajÄ…c bezpieczeÅ„stwo i elastycznoÅ›Ä‡.

2. Listing 10.6 â†’ Czy obiekt klasy Kwadrat wyÅ›wietla siÄ™ poprawnie? Dlaczego?
To zaleÅ¼y od implementacji klasy Kwadrat.

JeÅ›li Kwadrat jest klasÄ… dziedziczÄ…cÄ… po Prostokat i ma wÅ‚asnÄ… metodÄ™ doTekstu() przesÅ‚aniajÄ…cÄ… (overriding) tÄ™ z Prostokat, to operator << wywoÅ‚any na obiekcie Kwadrat (przez cout << k) wyÅ›wietli poprawny tekst specyficzny dla Kwadrat, pod warunkiem Å¼e wywoÅ‚anie doTekstu() jest wirtualne w klasie bazowej (Prostokat).

JeÅ›li doTekstu() nie jest metodÄ… wirtualnÄ…, to wywoÅ‚anie prostokat.doTekstu() w operatorze << wywoÅ‚a metodÄ™ klasy Prostokat, nawet jeÅ›li obiekt jest klasy Kwadrat, co spowoduje, Å¼e obiekt Kwadrat moÅ¼e siÄ™ nie wyÅ›wietlaÄ‡ poprawnie.

Listing 10.7, wiersze 1 i 2 â†’ Czy argumenty mogÄ… byÄ‡ przekazane jako referencje do staÅ‚ych?
Argument istream &strumien nie moÅ¼e byÄ‡ referencjÄ… do staÅ‚ej (const), poniewaÅ¼ operator >> odczytuje dane ze strumienia i modyfikuje jego stan (np. wskaÅºnik pozycji w strumieniu), wiÄ™c strumieÅ„ musi byÄ‡ modyfikowalny.

Argument Prostokat &prostokat nie powinien byÄ‡ przekazany jako referencja do staÅ‚ej (const), poniewaÅ¼ operator >> musi zmodyfikowaÄ‡ obiekt prostokat (np. zmieniÄ‡ jego boki za pomocÄ… zmienBoki), wiÄ™c musi mieÄ‡ dostÄ™p do niemodyfikowalnej referencji.

1. Jaka jest rÃ³Å¼nica pomiÄ™dzy operatorami postinkrementacji i preinkrementacji?
Preinkrementacja (++obj) â€“ najpierw zwiÄ™ksza wartoÅ›Ä‡ obiektu, potem zwraca odwoÅ‚anie do zmodyfikowanego obiektu.

Postinkrementacja (obj++) â€“ najpierw zwraca kopiÄ™ obiektu przed zwiÄ™kszeniem, a dopiero potem zwiÄ™ksza wartoÅ›Ä‡ obiektu.

W praktyce:

Preinkrementacja jest zazwyczaj bardziej efektywna (nie wymaga kopiowania).

Postinkrementacja wymaga dodatkowego parametru int (ktÃ³ry nie jest uÅ¼ywany) tylko po to, aby odrÃ³Å¼niÄ‡ jÄ… od preinkrementacji.

2. Listing 10.9, wiersz 1 â†’ Po co jest ten int?
Parametr int w definicji operatora operator++(int) jest sztucznym parametrem sÅ‚uÅ¼Ä…cym do rozrÃ³Å¼nienia operatora postinkrementacji od preinkrementacji, ktÃ³ra nie ma Å¼adnych parametrÃ³w.

3. Listing 10.9, wiersze od 3 do 7 â†’ Co oznacza this?
this to wskaÅºnik do bieÅ¼Ä…cego obiektu klasy, na ktÃ³rym wywoÅ‚ywana jest metoda. UmoÅ¼liwia dostÄ™p do jego pÃ³l i metod.

4. Listing 10.9, wiersze od 3 do 6 â†’ Czy this jest niezbÄ™dny?
Nie jest niezbÄ™dny jeÅ›li nie ma konfliktu nazw, np. gdy nie ma lokalnych zmiennych lub parametrÃ³w o takiej samej nazwie jak pola klasy. MoÅ¼na napisaÄ‡:

bok1 *= 2;
bok2 *= 2;
obliczPole();
obliczObwod();
i kod bÄ™dzie dziaÅ‚aÅ‚ tak samo.

1. Co to oznacza, Å¼e definicja metody jest wewnÄ…trz definicji klasy?
Gdy metoda jest zdefiniowana wewnÄ…trz definicji klasy (czyli w ciele klasy, a nie tylko zadeklarowana), jest traktowana jako metoda inline. Oznacza to, Å¼e kompilator moÅ¼e (ale nie musi) wstawiÄ‡ kod tej funkcji bezpoÅ›rednio w miejsce jej wywoÅ‚ania, co moÅ¼e przyspieszyÄ‡ dziaÅ‚anie programu przez unikniÄ™cie wywoÅ‚aÅ„ funkcji.

2. Listing 10.11, wiersze 2 i 3 â†’ W jaki sposÃ³b wyÅ›wietlana jest zmienna typu bool?
DomyÅ›lnie zmienna typu bool wyÅ›wietlana jest jako 0 (dla false) lub 1 (dla true) w standardowym strumieniu cout.

JeÅ›li chcemy, aby zamiast cyfr pojawiaÅ‚y siÄ™ sÅ‚owa true lub false, naleÅ¼y uÅ¼yÄ‡:

cout << boolalpha;
PrzykÅ‚ad:

cout << boolalpha << (!p0) << endl;
















